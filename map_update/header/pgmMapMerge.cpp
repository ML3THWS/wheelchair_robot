//implementation of the pgmMapMerge class
#include "pgmMapMerge.h"

//implementing class constructor
pgmMapMerge::pgmMapMerge(pgmMapCheck *passed_initial_map, vector<pgmMapCheck> *passed_maps, string initial_map_yaml_file_path){
	
	count_maps_to_compare = passed_maps->size();	//minus one because first element is the initial map so we only have size()-1 maps generated by pgmMapCompare which we need to merge
	
	if(check_count()){
		
		for(int i = 0; i < passed_maps->size(); i++){		//accessing all arguments of va_list
			maps_to_merge.push_back((passed_maps->at(i).occupancy_grid_map())); //give all passed maps to the maps_to_merge vector of maps	
		}
		
		changable_grid_matrix = (passed_initial_map->check_changable_grid_cells());
		initial_map = passed_initial_map->occupancy_grid_map();		//first element of the given maps NEEDS to be the initial map, which we safe to another parameter
		resulting_map = initial_map;
		merge_compared_maps();
		path_to_initial_map_yaml_file = initial_map_yaml_file_path;
		std::cout << "Maps merged!" << std::endl;
	}
	else{
		std::cerr << "Map merge not possible! Not enough Maps passed to the class constructor. Make sure you have at least passed the initial and a pgmMapCompare class generated map (2 maps in total) to the class constructor." << std::endl;
	}
	
}

//implementing destructor
pgmMapMerge::~pgmMapMerge()
{

}

//implementing function to check if enough maps (at lest the inital and one pgmMapCompare class generated map) have been passed to the pgmMapMerge class
bool pgmMapMerge::check_count()
{
	if(count_maps_to_compare >= 1){
		return true;
	}
	else{
		return false;
	}
}

//implementing map size check
bool pgmMapMerge::check_compatible_map_sizes()
{
	for(int i = 0; i < count_maps_to_compare; i++){
		
		if(initial_map.size() == maps_to_merge.at(i).size()){
			if(initial_map.size() > 0){
				if(initial_map.at(0).size() == maps_to_merge.at(i).at(0).size()){
					continue;
				}
				else{
					std::cerr << "Sizes of the given maps are note the same/compatible. Make sure all the given maps originate from one base/initial map and have the same x and y size!" << std::endl;
					return false;
				}
			}
			else{	
				std::cout << "Map sizes are zero 0. Map is completely empty (PGM file is empty)" << std::endl;
			}
		}
		else{
			std::cerr << "Sizes of the given maps are note the same/compatible. Make sure all the given maps originate from one base/initial map and have the same x and y size!" << std::endl;
			return false;
		}
	}
	
	return true;
}


//implementing coodinate extract function
void pgmMapMerge::merge_compared_maps() //ANPASSEN /nun angepasst
{	
	if(check_compatible_map_sizes()){

		array<uint16_t, 2> coordinate = {0,0};		//coordinates in y and x [y, y]

		for(int i=0; i < initial_map.size(); i++){
			for(int a=0; a < initial_map.at(i).size(); a++){
				
				if(initial_map.at(i)[a] == 0){

					if(!(changable_grid_matrix.at(i)[a])){						//just used as a safety feature because normally all occupied cells shouldnt be changable 

						bool removed_object = false;			//boolean variable to indicate if possible removed obj has been found

						for(int map = 0; map < count_maps_to_compare; map++){

							if(maps_to_merge.at(map).at(i)[a] == 254){			//check if the initial map has an occupied cell where the unoccupied 								
								
								if(resulting_map[i][a] == 0){					//also check if the resulting map for this pixel might already been changed
																//and updated grid map (after costmap update) has a free cell
									removed_object = true;
									break;
									//find_removed_objects_grid_cell_groups({(uint16_t)i, (uint16_t)a});
								}
							}
						}

						if(removed_object){
							find_removed_objects_grid_cell_groups({(uint16_t)i, (uint16_t)a});
							removed_object = false;
						}
					}
				}
				
				bool new_object = false;					//boolean object to inidicate that possible new object has been found
				
				for(int maps = 0; maps < count_maps_to_compare; maps++){

					if(maps_to_merge.at(maps).at(i)[a] == 0){
						
						if(changable_grid_matrix.at(i)[a]){		//only (possible) new object coordinates should be saved therefore
												//we check if the inital map already had an occupied cell on the same coordinate
												//or nearby (because of the measurement error of the lidar) which we can get from the changable_grid_matrix 
															
							if(resulting_map[i][a] != 0){		//checking if the now used occupied cell has already been put into the resulting map
								new_object = true;
								break;
								//find_new_object_grid_cell_groups({(uint16_t)i, (uint16_t)a});
							}
							
						}
					}
				}

				if(new_object){
					find_new_object_grid_cell_groups({(uint16_t)i, (uint16_t)a});
					new_object = false;
				}
			}
		}
	}
	else{
		std::cerr << "Base/Initial Map, Clearing Map and No Clearing Map are not compatible. Error: Different Map sizes!! \n Could not extract coordinates from maps!" << std::endl;
	}
	
}

//implementing function to find groups of cells which belong to a new object
//this function is a recursive function
void pgmMapMerge::find_new_object_grid_cell_groups(array<uint16_t, 2> coord) //ANPASSEN
{
	if(changable_grid_matrix.at(coord[0])[coord[1]]){					//check if the given coordinate is changable

		if(check_cell_in_maps_to_merge(coord[0], coord[1]) == 0){

			resulting_map[coord[0]][coord[1]] = uint8_t(0);						//change given cell to occupied
			
			bool left=false, right=false, upper=false, lower=false;				//boolean values to search for not matching occupied cells in the resulting and no_clearing_map
			
			array<uint16_t, 2> coordinate; 							//variable to store the coordinate of an "unknown" grid cell for the next rekursive call of this function
			
			//following we checkt that the index we want to call is not out of bounds
			if((coord[0]-1) >= 0){
				upper = true;
			}
			if((coord[1]-1) >= 0){
				left = true;
			}
			if((coord[0]+1) < resulting_map.size()){
				lower = true;
			}
			if((coord[1]+1) < resulting_map[coord[0]].size()){
				right = true;
			}

			//now we search for changable and not equal occupied cells in the resluting and no clearing map 
			//here we search in a certain pattern which is: 	6 | 7 | 8
			//							5 | 0 | 1
			//							4 | 3 | 2
			if(right){

				if(changable_grid_matrix.at(coord[0])[coord[1]+1]){
					if(!((resulting_map[coord[0]][coord[1]+1]) == (check_cell_in_maps_to_merge(coord[0], coord[1]+1)))){
						coordinate = {coord[0], (uint16_t)(coord[1]+1)}; 
						find_new_object_grid_cell_groups(coordinate);
					}
				}
				
				if(lower){
					if(changable_grid_matrix.at(coord[0]+1)[coord[1]+1]){
						if(!((resulting_map[coord[0]+1][coord[1]+1]) == (check_cell_in_maps_to_merge(coord[0]+1, coord[1]+1)))){
							coordinate = {(uint16_t)(coord[0]+1), (uint16_t)(coord[1]+1)};
							find_new_object_grid_cell_groups(coordinate);
						}
					}
				}
			}

			if(lower){

				if(changable_grid_matrix.at(coord[0]+1)[coord[1]]){
					if(!((resulting_map[coord[0]+1][coord[1]]) == (check_cell_in_maps_to_merge(coord[0]+1, coord[1])))){
						coordinate = {(uint16_t)(coord[0]+1), (coord[1])};
						find_new_object_grid_cell_groups(coordinate);
					}
				}

				if(left){
					if(changable_grid_matrix.at(coord[0]+1)[coord[1]-1]){
						if(!((resulting_map[coord[0]+1][coord[1]-1]) == (check_cell_in_maps_to_merge(coord[0]+1, coord[1]-1)))){
							coordinate = {(uint16_t)(coord[0]+1), (uint16_t)(coord[1]-1)};
							find_new_object_grid_cell_groups(coordinate);
						}
					}
				}
			}

			if(left){

				if(changable_grid_matrix.at(coord[0])[coord[1]-1]){
					if(!((resulting_map[coord[0]][coord[1]-1]) == (check_cell_in_maps_to_merge(coord[0], coord[1]-1)))){
						coordinate = {coord[0], (uint16_t)(coord[1]-1)}; 
						find_new_object_grid_cell_groups(coordinate);
					}
				}

				if(upper){
					if(changable_grid_matrix.at(coord[0]-1)[coord[1]-1]){
						if(!((resulting_map[coord[0]-1][coord[1]-1]) == (check_cell_in_maps_to_merge(coord[0]-1, coord[1]-1)))){
							coordinate = {(uint16_t)(coord[0]-1), (uint16_t)(coord[1]-1)};
							find_new_object_grid_cell_groups(coordinate);
						}
					}
				}
			}

			if(upper){

				if(changable_grid_matrix.at(coord[0]-1)[coord[1]]){
					if(!((resulting_map[coord[0]-1][coord[1]]) == (check_cell_in_maps_to_merge(coord[0]-1, coord[1])))){
						coordinate = {(uint16_t)(coord[0]-1), (coord[1])};
						find_new_object_grid_cell_groups(coordinate);
					}
				}

				if(right){
					if(changable_grid_matrix.at(coord[0]-1)[coord[1]+1]){
						if(!((resulting_map[coord[0]-1][coord[1]+1]) == (check_cell_in_maps_to_merge(coord[0]-1, coord[1]+1)))){
							coordinate = {(uint16_t)(coord[0]-1), (uint16_t)(coord[1]+1)};
							find_new_object_grid_cell_groups(coordinate);
						}
					}
				}
			}

		}

	}
	
}

//implementing function to find groups of cells which belong to a (re-)moved object
//this function is a recursive function
void pgmMapMerge::find_removed_objects_grid_cell_groups(array<uint16_t, 2> coord) //ANPASSEN
{
	if(!(changable_grid_matrix.at(coord[0])[coord[1]])){							//check if given coordinate is normally not changable because (before) occupied cells should not be changable (plus an unchangable radius)

		resulting_map[coord[0]][coord[1]] = check_for_unoccupied_cell_in_maps_to_merge(coord[0], coord[1]);		//change given cell to free
		
		bool left=false, right=false, upper=false, lower=false;						//boolean values to search for not matching occupied cells in the resulting and unoccupied_cost_base_map
		
		array<uint16_t, 2> coordinate; 									//variable to store the coordinate of an "unknown" grid cell for the next rekursive call of this function
		
		//following we checkt that the index we want to call is not out of bounds
		if((coord[0]-1) >= 0){
			upper = true;
		}
		if((coord[1]-1) >= 0){
			left = true;
		}
		if((coord[0]+1) < resulting_map.size()){
			lower = true;
		}
		if((coord[1]+1) < resulting_map[coord[0]].size()){
			right = true;
		}

		//now we search for not changable and not equal occupied cells in the resluting and unoccupied map 
		//here we search in a certain pattern which is: 	6 | 7 | 8
		//							5 | 0 | 1
		//							4 | 3 | 2
		if(right){

			if(!(changable_grid_matrix.at(coord[0])[coord[1]+1])){
				if((resulting_map[coord[0]][coord[1]+1] == 0) && (check_for_unoccupied_cell_in_maps_to_merge(coord[0], coord[1]+1) == 254)){
					coordinate = {coord[0], (uint16_t)(coord[1]+1)}; 
					find_removed_objects_grid_cell_groups(coordinate);
				}
			}
			
			if(lower){
				if(!(changable_grid_matrix.at(coord[0]+1)[coord[1]+1])){
					if((resulting_map[coord[0]+1][coord[1]+1] == 0) && (check_for_unoccupied_cell_in_maps_to_merge(coord[0]+1, coord[1]+1) == 254)){
						coordinate = {(uint16_t)(coord[0]+1), (uint16_t)(coord[1]+1)};
						find_removed_objects_grid_cell_groups(coordinate);
					}
				}
			}
		}

		if(lower){

			if(!(changable_grid_matrix.at(coord[0]+1)[coord[1]])){
				if((resulting_map[coord[0]+1][coord[1]] == 0) && (check_for_unoccupied_cell_in_maps_to_merge(coord[0]+1, coord[1]) == 254)){
					coordinate = {(uint16_t)(coord[0]+1), (coord[1])};
					find_removed_objects_grid_cell_groups(coordinate);
				}
			}

			if(left){
				if(!(changable_grid_matrix.at(coord[0]+1)[coord[1]-1])){
					if((resulting_map[coord[0]+1][coord[1]-1] == 0) && (check_for_unoccupied_cell_in_maps_to_merge(coord[0]+1, coord[1]-1) == 254)){
						coordinate = {(uint16_t)(coord[0]+1), (uint16_t)(coord[1]-1)};
						find_removed_objects_grid_cell_groups(coordinate);
					}
				}
			}
		}

		if(left){

			if(!(changable_grid_matrix.at(coord[0])[coord[1]-1])){
				if((resulting_map[coord[0]][coord[1]-1] == 0) && (check_for_unoccupied_cell_in_maps_to_merge(coord[0], coord[1]-1) == 254)){
					coordinate = {coord[0], (uint16_t)(coord[1]-1)}; 
					find_removed_objects_grid_cell_groups(coordinate);
				}
			}

			if(upper){
				if(!(changable_grid_matrix.at(coord[0]-1)[coord[1]-1])){
					if((resulting_map[coord[0]-1][coord[1]-1] == 0) && (check_for_unoccupied_cell_in_maps_to_merge(coord[0]-1, coord[1]-1) == 254)){
						coordinate = {(uint16_t)(coord[0]-1), (uint16_t)(coord[1]-1)};
						find_removed_objects_grid_cell_groups(coordinate);
					}
				}
			}
		}

		if(upper){

			if(!(changable_grid_matrix.at(coord[0]-1)[coord[1]])){
				if((resulting_map[coord[0]-1][coord[1]] == 0) && (check_for_unoccupied_cell_in_maps_to_merge(coord[0]-1, coord[1]) == 254)){
					coordinate = {(uint16_t)(coord[0]-1), (coord[1])};
					find_removed_objects_grid_cell_groups(coordinate);
				}
			}

			if(right){
				if(!(changable_grid_matrix.at(coord[0]-1)[coord[1]+1])){
					if((resulting_map[coord[0]-1][coord[1]+1] == 0) && (check_for_unoccupied_cell_in_maps_to_merge(coord[0]-1, coord[1]+1) == 254)){
						coordinate = {(uint16_t)(coord[0]-1), (uint16_t)(coord[1]+1)};
						find_removed_objects_grid_cell_groups(coordinate);
					}
				}
			}
		}


	}
}

//implement function to check if all maps used for merging have the same cell value at a given coordinate
uint8_t pgmMapMerge::check_cell_in_maps_to_merge(uint16_t y, uint16_t x){
	
	uint8_t cell_val = uint8_t(0);

	for(int map = 0; map < count_maps_to_compare; map++){
		if(cell_val != maps_to_merge.at(map).at(y)[x] ){
			cell_val = maps_to_merge.at(map).at(y)[x];
			break;
		}
	}

	return  cell_val;
}

//implementing a function which check if one of the maps_to_merge has a free (unoccupied) cell at a given coordiante
uint8_t pgmMapMerge::check_for_unoccupied_cell_in_maps_to_merge(uint16_t y, uint16_t x){

	uint8_t cell_val = uint8_t(254);

	for(int map = 0; map < count_maps_to_compare; map++){
		if(cell_val != maps_to_merge.at(map).at(y)[x] ){
			cell_val = maps_to_merge.at(map).at(y)[x];
			break;
		}
	}

	return  cell_val;

}

//implementing a function which returns the new merged map
vector<vector<uint8_t>> pgmMapMerge::merge_result_map(){
	return resulting_map;
}

//implement function which will be used to generate a new map as a .pgm and .yaml file that is created by merging maps from different days into one map
bool pgmMapMerge::write_new_updated_map_pgm_and_yaml(string path_to_new_map_file_loc, string name_of_new_map){

	std::ifstream map_description_load; 					//loader for yaml file corresponding to base/initial map pgm file
	map_description_load.open(path_to_initial_map_yaml_file, std::ios::in);	//load corresponding yaml file

	string map_yaml_file_data[6];					//array of strings to load YAML-file data

	if(map_description_load.is_open()){
		for(int i = 0; i<6; i++){
			std::getline(map_description_load, map_yaml_file_data[i]);					//get the data from the original base (initial) map file
		}
		string check_for_space = "";
		while(check_for_space != " "){
			check_for_space = map_yaml_file_data[0][map_yaml_file_data[0].length()-1];
			map_yaml_file_data[0].pop_back();
		};
		map_yaml_file_data[0] = map_yaml_file_data[0] + " " + name_of_new_map + ".pgm";				//created pgm file will always be called base_map_without_occupied_cells.pgm

	}
	else{
		std::cerr << "Could not open corresponding YAML file to the base (initial) map file at: " << path_to_initial_map_yaml_file << " for reading!" << std::endl;
		return false;
	}

	std::ofstream map_write_all;											//object for writing the new yaml file from the compared maps
	map_write_all.open((path_to_new_map_file_loc +  "/" + name_of_new_map + ".yaml"), std::ios_base::out);		//open new file for writing new yaml file for compared map
	
	if(map_write_all.is_open()){
		//write the initial map header data received upon creating this object
		for(int i = 0; i<6; i++){
			map_write_all << map_yaml_file_data[i] << std::endl;
		}

		std::cout << "YAML file for new compared map generated! (File name: " <<  "/" << name_of_new_map << ".yaml)" << std::endl;

		map_write_all.close();
	}
	else{
		std::cerr << "Failed to open new file for generating " << name_of_new_map << ".yaml file" << std::endl;
		return false;
	}

	map_write_all.open((path_to_new_map_file_loc +  "/" + name_of_new_map + ".pgm"), std::ios_base::out);	//open new file for writing new pgm file for compared map	
	
	if(map_write_all.is_open()){
				
		if(check_compatible_map_sizes()){

			//write the initial map header data received upon creating this object
			map_write_all << "P5" << std::endl;
			map_write_all << "# CREATOR: pgmMapCompare class" << std::endl;
			map_write_all << resulting_map.at(0).size() << " " << resulting_map.size() << std::endl;
			map_write_all << 255 << std::endl;

			//write the received map grid values into new file (need to be char!)
			for(int i=0; i < resulting_map.size(); i++){
				for(int a=0; a < resulting_map[i].size(); a++){
					
					map_write_all << resulting_map[i][a];
				}
			}

			std::cout << "Generated new map file (File name: " << name_of_new_map << ".pgm)" << std::endl;
		}
			map_write_all.close();

	}
	else{
		std::cerr << "Failed to open new file for generating " << name_of_new_map << ".pgm" << std::endl;
		return false;
	}

	return true;
}

//implementing a function which returns the new merged map but with the edits the map creator made to the initial map
//for example for objects like glass or for areas the robot should not go to
vector<vector<uint8_t>> pgmMapMerge::merge_result_with_edit(pgmMapCheck *initial_map_with_edit){
	vector<vector<uint8_t>> resulting_map_with_edit = resulting_map;
	vector<vector<uint8_t>> initial_edited_map = initial_map_with_edit->occupancy_grid_map();

	if(check_compatible_map_sizes()){
		if(initial_map.size() == initial_edited_map.size()){
			if(initial_map.at(0).size() == initial_edited_map.at(0).size()){
				for(int i=0; i < resulting_map_with_edit.size(); i++){
					for(int a=0; a < resulting_map_with_edit[i].size(); a++){
						if(initial_map[i][a] !=  initial_edited_map[i][a]){			//if there is a difference between the initial map and the initial edited map (so something we edited in the initial map)
							resulting_map_with_edit[i][a] = initial_edited_map[i][a];	//we insert this differentiating pixel into the resulting map (so we add the edited objects/things into the new resulting map)
						}
					}
				}
				return resulting_map_with_edit;
			}
			else{
				std::cerr << "Initial map and the edited initial map are not compatible/do not have the same size! \nThe returned map does NOT have the edited parts added inside of it!" << std::endl;
				return resulting_map_with_edit;
			}
		}
		else{
			std::cerr << "Initial map and the edited initial map are not compatible/do not have the same size! \nThe returned map does NOT have the edited parts added inside of it!" << std::endl;
			return resulting_map_with_edit;
		}
	}
	else{
		std::cerr << "The given map sizes are in general not compatible/maps do not have the same size! \nThe returned map does NOT have the edited parts added inside of it!" << std::endl;
		return resulting_map_with_edit;
	}
}